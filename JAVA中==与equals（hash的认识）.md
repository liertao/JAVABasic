	他们在比较对象的时候都是根据hashCode()方法返回的哈希码来判断两个对象是否相等的，所以要想搞清楚equals()就必须要知道什么是哈希码。
	Object的hashCode()方法返回的哈希码是根据对象的内存地址来生成的，所以每个对象的哈希码
是不相同的，如果你要比较的两个变量的类型没有重写Object的hashCode()方法那么这两个变量除非是指向相同的对象（地址相同），否则返回的一定是false。而String以及基本数据类型的包装类中都重写
了hashCode()方法，他们生成的哈希码是跟他们的内容（这里就是指值）息息相关，也就是说在用equals()比较两个变量是否相等的时候只要他们的值相等，那么就返回true，因为他们生成的哈希码相等。有
个值得注意的地方是：在JDK的类中只要重写的Object的equals()方法，那就肯定重写了它的hashCode()方法，因为equals()方法中在比较两个变量时，判断的标准就是哈希码是否一样，Object中的hashCode()
方法是根据对象的内存地址生成的，如果重写了equals()方法而继续使用原来的hashCode()方法生成的哈希码作为判断相等的依据，那显然达不到我们要改变判断对象是否相等的标准的效果。
	对于没用重写Object的equals()方法的类型所生成的对象的比较，equals()和==是效果一样的，==比较的是两个变量所指向的对象
在内存中指向的地址是否一样，而当两个变量的类型中继承了Object的equals()方法的时候，由于该方法比较的标准是看哈希码是否相等，而哈希码是由hashCode()方法生成的，该方法生成哈希码的依据是对
象在内存中的地址，最终比较的还是地址。所以说equals()和==效果一样。
	而对于像String和那些基本数据类型的包装类来说equals()和==就不一样了，因为他们重写了Object的equals()方法和hashCode()方
法，使得equals()方法的判断标准发生了改变，他们的判断标准是看对象的内容是否相等，这里就是指值是不是一样，因为他们的哈希码是根据对象的值生成的，与内存地址无关了，所以他们的equals()方法
比较的是对象的值是否相等，而==比较的仍然是地址。所以equals()和==就不一样了。
	这里还要注意一下，在比较值的时候，一般==比较的是基本数据类型，而equals()比较的是引用数据类型，地址相同一定值相等，而值相等地址不一定相同。如果比较的是地址，那最好是用==，因为
无论是否重写了Object的equals()方法，==永远比较的是地址,equals()比较的是哈希码，而哈希码生成的标准是由类作者自己根据需求来控制的。

	求证终于获得了一点启示，和大家分享一下，在java的集合中，判断两个对象是否相等的规则是：
1)，判断两个对象的hashCode是否相等
如果不相等，认为两个对象也不相等，完毕
如果相等，转入2)
（这一点只是为了提高存储效率而要求的，其实理论上没有也可以，但如果没有，实际使用时效率会大大降低，所以我们这里将其做为必需的。后面会重点讲到这个问题。）
2)，判断两个对象用equals运算是否相等
如果不相等，认为两个对象也不相等
如果相等，认为两个对象相等（equals()是判断两个对象是否相等的关键） 为什么是两条准则，难道用第一条不行吗？不行，因为前面已经说了，hashcode()相等时，
equals()方法也可能不等，所以必须用第2条准则进行限制，才能保证加入的为非重复元素。